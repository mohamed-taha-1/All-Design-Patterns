# Design Patterns in Java

## Description

This repository contains Java implementations of various design patterns. Design patterns are proven solutions to common software design problems that promote code reusability, maintainability, and flexibility. Each pattern is implemented with a simple example to demonstrate its usage.

## Table of Contents

- [Creational Patterns](#creational-patterns)
- [Structural Patterns](#structural-patterns)
- [Behavioral Patterns](#behavioral-patterns)
## Creational Patterns

```
https://github.com/mohamed-taha-1/All-Design-Patterns/tree/general/src/designPatterns/creational

1. Singleton Pattern: Ensures a class has only one instance and provides a global access point to that instance.

2. Factory Method Pattern: Provides an interface for creating objects, but allows subclasses to decide which class to instantiate.

3. Abstract Factory Pattern: Provides an interface for creating families of related objects without specifying their concrete classes.

4. Builder Pattern: Constructs complex objects step by step, separating construction from the representation.

## Structural Patterns

1. Adapter Pattern: Converts the interface of a class into another interface that clients expect. It allows incompatible classes to work together.

2. Decorator Pattern: Adds behavior to objects dynamically, without modifying their code directly. It is useful for extending functionality.

3. Facade Pattern: Provides a unified interface to a set of interfaces in a subsystem. It simplifies complex systems by providing a higher-level interface.

4. Proxy Pattern: Provides a surrogate or placeholder for another object to control access to it.

## Behavioral Patterns

1. Observer Pattern: Defines a one-to-many dependency between objects. When one object changes state, all its dependents are notified and updated automatically.

2. Strategy Pattern: Defines a family of algorithms, encapsulates each one, and makes them interchangeable. It allows selecting an algorithm at runtime.

3. Template Method Pattern: Defines the skeleton of an algorithm in a method, allowing subclasses to redefine certain steps of the algorithm without changing its structure.

4. Command Pattern: Encapsulates a request as an object, allowing parameterization of clients with different requests, queuing, and logging of requests.
